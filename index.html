import os
import logging
import random
from typing import List, Dict
from flask import Flask, request, jsonify
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_cors import CORS
import requests
import tweepy
from newsapi import NewsApiClient
import redis
from datetime import datetime

# Initialize logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load environment variables
from dotenv import load_dotenv
load_dotenv()

# Initialize Flask app
app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": os.getenv('CORS_ORIGINS').split(',')}})

# Initialize Redis
redis_client = redis.Redis.from_url(os.getenv('REDIS_URL'))

# Initialize rate limiting
limiter = Limiter(app=app, key_func=get_remote_address, storage_uri=os.getenv('REDIS_URL'))

# Configuration
CONFIG = {
    'reddit': {
        'client_id': os.getenv('REDDIT_CLIENT_ID'),
        'client_secret': os.getenv('REDDIT_CLIENT_SECRET')
    },
    'twitter': {
        'bearer_token': os.getenv('TWITTER_BEARER_TOKEN')
    },
    'newsapi': os.getenv('NEWSAPI_KEY'),
    'monetization': {
        'free_tier': {'daily_limit': 2, 'rate_limit': '2/day'},
        'pro_tier': {'daily_limit': 100, 'rate_limit': '10/minute'}
    }
}

# Initialize APIs
newsapi = NewsApiClient(api_key=CONFIG['newsapi'])
twitter_api = tweepy.Client(bearer_token=CONFIG['twitter']['bearer_token'])

# Enhanced topic database
TOPIC_DATABASE = {
    "AI": [
        "ðŸš€ AI is taking over. Hereâ€™s how you can profit before itâ€™s too late!",
        "ðŸ¤– Neural networks now predict consumer behavior with 87% accuracy!",
    ],
    "Business": [
        "ðŸ’° Recession-proof business models thriving right now! Donâ€™t miss out!",
        "ðŸ“ˆ How storytelling creates deep emotional connections with customers!",
    ],
    # Add more topics as needed
}

# Copywriting templates
FRAMEWORKS = {
    'hook_problem_solution': [
        "ðŸ”¥ {hook} (But here's what nobody is telling you...)",
        "ðŸ’” The REAL problem: {problem}",
        "ðŸ’¡ BREAKTHROUGH: {insight}",
        "ðŸš€ Solution: {solution} (ðŸ‘‰ {cta})"
    ],
    'listicle': [
        "ðŸš€ {count} {topic} Secrets Top Experts Won't Tell You:",
        "1ï¸âƒ£ {point1}",
        "2ï¸âƒ£ {point2}",
        "3ï¸âƒ£ {point3}",
        "ðŸ”‘ The Key: {key_insight} (ðŸ‘‰ {cta})"
    ]
}

CTAS = [
    "Grab your FREE guide â†’ [LINK]",
    "Join our premium community â†’ [LINK]",
    "Book your AI consultation â†’ [LINK]"
]

# Helper functions
def get_user_tier(api_key: str) -> str:
    """Check user subscription status"""
    return 'pro' if api_key else 'free'

def fetch_reddit_trends() -> List[str]:
    """Fetch trending topics from Reddit"""
    try:
        token = get_reddit_token()
        headers = {'Authorization': f'Bearer {token}', 'User-Agent': 'TwitterThreadGenerator/1.0'}
        response = requests.get('https://www.reddit.com/r/popular/top.json?limit=10', headers=headers, timeout=5)
        if response.status_code == 200:
            return [post['data']['title'] for post in response.json().get('data', {}).get('children', [])]
    except Exception as e:
        logger.error(f"Reddit trends error: {e}")
    return []

def fetch_twitter_trends() -> List[str]:
    """Fetch trending topics from Twitter"""
    try:
        trends = twitter_api.get_place_trends(id=1)  # Worldwide trends
        return [trend['name'] for trend in trends[0]['trends']][:10]
    except Exception as e:
        logger.error(f"Twitter trends error: {e}")
    return []

def fetch_news_trends() -> List[str]:
    """Fetch trending news headlines"""
    try:
        news = newsapi.get_top_headlines(language='en', page_size=10)
        return [article['title'] for article in news.get('articles', [])]
    except Exception as e:
        logger.error(f"News trends error: {e}")
    return []

def fetch_trending_topics() -> List[str]:
    """Aggregate trends from multiple sources with caching"""
    cache_key = f"trends:{datetime.now().strftime('%Y-%m-%d')}"
    if redis_client.exists(cache_key):
        return [t.decode('utf-8') for t in redis_client.smembers(cache_key)]
    
    sources = {
        'reddit': fetch_reddit_trends(),
        'twitter': fetch_twitter_trends(),
        'news': fetch_news_trends()
    }
    
    # Combine and weight trends
    all_trends = []
    for source, trends in sources.items():
        all_trends.extend([(t, source) for t in trends])
    
    # Store in Redis with 6h expiration
    redis_client.sadd(cache_key, *[t[0] for t in all_trends])
    redis_client.expire(cache_key, 21600)
    
    return [t[0] for t in all_trends]

def generate_thread_structure(topic: str, insights: List[str]) -> List[str]:
    """Apply copywriting framework to raw insights"""
    framework = random.choice(list(FRAMEWORKS.values()))
    selected_insights = random.sample(insights, len(framework)-1)
    
    thread = []
    for i, template in enumerate(framework):
        thread.append(template.format(
            hook=selected_insights[0],
            problem=selected_insights[1],
            insight=selected_insights[2],
            solution=selected_insights[3],
            cta=random.choice(CTAS),
            count=len(selected_insights),
            topic=topic
        ))
    
    # Add viral elements
    thread.insert(1, "ðŸ§µðŸ‘‡ (Thread) â†“")
    thread.append(f"ðŸ’¡ Want more like this? â†’ {random.choice(CTAS)}")
    
    return thread

# API Endpoint
@app.route('/generate', methods=['POST'])
@limiter.limit(lambda: CONFIG['monetization'][get_user_tier(request.headers.get('X-API-Key'))]['rate_limit'])
def generate_thread():
    """Main generation endpoint"""
    try:
        # Authentication and authorization
        user_tier = get_user_tier(request.headers.get('X-API-Key'))
        usage_key = f"usage:{request.remote_addr}"
        
        if user_tier == 'free':
            current_usage = int(redis_client.get(usage_key) or 0
            if current_usage >= CONFIG['monetization']['free_tier']['daily_limit']:
                return jsonify({"error": "Daily limit exceeded. Upgrade to PRO."}), 429
        
        # Process request
        data = request.json
        topic = data.get('topic', random.choice(list(TOPIC_DATABASE.keys())))
        
        # Fetch insights
        insights = fetch_trending_topics()
        
        # Generate thread
        thread = generate_thread_structure(topic, insights)
        
        # Track usage
        if user_tier == 'free':
            redis_client.incr(usage_key)
            redis_client.expire(usage_key, 86400)  # Reset after 24 hours
        
        return jsonify({
            "thread": thread,
            "cta": random.choice(CTAS),
            "monetization": {
                "upsell": "Unlock 100x more insights with PRO â†’ [LINK]" if user_tier == 'free' else None
            }
        })
    
    except Exception as e:
        logger.error(f"Generation error: {e}")
        return jsonify({"error": str(e)}), 500

# Run the app
if __name__ == '__main__':
    app.run(debug=True)
