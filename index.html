from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import random
import requests
import os
import logging
from typing import List, Dict, Union

# Initialize logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": os.getenv('CORS_ORIGINS', 'https://kyle4814.github.io').split(',')}})

# Rate limiting
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

# Configuration
API_CONFIG = {
    'reddit_client_id': os.getenv('REDDIT_CLIENT_ID'),
    'reddit_client_secret': os.getenv('REDDIT_CLIENT_SECRET'),
    'news_api_key': os.getenv('NEWS_API_KEY')
}

# Load topic database from external file
TOPIC_DATABASE: Dict[str, List[str]] = {
    # ... (your existing topic database here)
}

def get_reddit_token() -> Union[str, None]:
    """Get Reddit OAuth2 access token."""
    try:
        response = requests.post(
            'https://www.reddit.com/api/v1/access_token',
            auth=requests.auth.HTTPBasicAuth(API_CONFIG['reddit_client_id'], API_CONFIG['reddit_client_secret']),
            data={'grant_type': 'client_credentials'},
            headers={'User-Agent': 'TwitterThreadGenerator/1.0'},
            timeout=5
        )
        return response.json().get('access_token') if response.status_code == 200 else None
    except Exception as e:
        logger.error(f"Reddit auth failed: {e}")
        return None

def fetch_reddit_insights(topic: str) -> List[str]:
    """Fetch trending posts from Reddit related to topic."""
    token = get_reddit_token()
    if not token:
        return []

    try:
        response = requests.get(
            f"https://www.reddit.com/search.json?q={topic}&limit=5&sort=relevance",
            headers={'Authorization': f'Bearer {token}', 'User-Agent': 'TwitterThreadGenerator/1.0'},
            timeout=5
        )
        if response.status_code == 200:
            return [post['data']['title'] for post in response.json().get('data', {}).get('children', [])]
    except Exception as e:
        logger.error(f"Reddit fetch error: {e}")
    return []

def fetch_news_trends() -> List[str]:
    """Fetch trending news headlines using News API."""
    try:
        response = requests.get(
            f"https://newsapi.org/v2/top-headlines?country=us&apiKey={API_CONFIG['news_api_key']}",
            timeout=5
        )
        if response.status_code == 200:
            return [article['title'] for article in response.json().get('articles', [])[:5]]
    except Exception as e:
        logger.error(f"News API error: {e}")
    return []

def validate_input(topics: List[str], num_threads: int, thread_length: int) -> Union[None, tuple]:
    """Validate input parameters."""
    if not isinstance(num_threads, int) or not 1 <= num_threads <= 10:
        return ("Invalid number of threads", 400)
    if not isinstance(thread_length, int) or not 1 <= thread_length <= 15:
        return ("Invalid thread length", 400)
    if any(topic not in TOPIC_DATABASE for topic in topics):
        return ("Invalid topics provided", 400)
    return None

@app.route('/generate_thread', methods=['POST'])
@limiter.limit("10 per minute")
def generate_thread():
    """Generate Twitter threads based on input parameters."""
    try:
        data = request.get_json()
        topics = [t.strip() for t in data.get("topic", "").split(",") if t.strip()]
        num_threads = min(int(data.get("num_threads", 1)), 10)
        thread_length = min(int(data.get("thread_length", 5)), 15)
        random_mode = data.get("random_mode", False)

        # Input validation
        if error := validate_input(topics, num_threads, thread_length):
            return jsonify({"error": error[0], "status": "error"}), error[1]

        threads = []
        used_insights = set()

        for _ in range(num_threads):
            # Select topic
            if random_mode or not topics:
                selected_topic = random.choice(list(TOPIC_DATABASE.keys()))
            else:
                selected_topic = random.choice(topics)

            # Fetch insights
            reddit_insights = fetch_reddit_insights(selected_topic)
            news_trends = fetch_news_trends()
            local_insights = TOPIC_DATABASE.get(selected_topic, [])
            
            # Combine and deduplicate
            combined = list(set(reddit_insights + news_trends + local_insights))
            available = [insight for insight in combined if insight not in used_insights]
            
            # Fallback to local insights if insufficient
            if len(available) < thread_length:
                available = [insight for insight in local_insights if insight not in used_insights]

            # Select final insights
            selected = random.sample(available, min(thread_length, len(available)))
            used_insights.update(selected)
            
            # Format thread
            threads.append([f"ðŸ”¥ {selected_topic}: {insight}" for insight in selected])

        return jsonify({
            "threads": threads,
            "status": "success",
            "meta": {
                "generated_threads": len(threads),
                "total_insights": len(used_insights)
            }
        })

    except Exception as e:
        logger.error(f"Generation error: {e}")
        return jsonify({"error": "Internal server error", "status": "error"}), 500

if __name__ == '__main__':
    logger.info("âœ¨ Insight Generator server is running!")
    app.run(host='0.0.0.0', port=int(os.getenv('PORT', 5000)), debug=os.getenv('DEBUG', 'false').lower() == 'true')
