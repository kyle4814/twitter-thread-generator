import os
import logging
import random
import time
from typing import List, Dict, Tuple
from flask import Flask, request, jsonify
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_cors import CORS
import requests
import tweepy
from newsapi import NewsApiClient
import redis
from datetime import datetime, timedelta

# Initialize core components
app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": os.getenv('CORS_ORIGINS').split(',')}})
redis_client = redis.Redis.from_url(os.getenv('REDIS_URL'))
limiter = Limiter(app=app, key_func=get_remote_address, storage_uri=os.getenv('REDIS_URL'))

# Configuration
CONFIG = {
    'reddit': {
        'client_id': os.getenv('REDDIT_CLIENT_ID'),
        'client_secret': os.getenv('REDDIT_CLIENT_SECRET')
    },
    'twitter': {
        'bearer_token': os.getenv('TWITTER_BEARER_TOKEN')
    },
    'newsapi': os.getenv('NEWSAPI_KEY'),
    'stripe': os.getenv('STRIPE_SECRET_KEY'),
    'monetization': {
        'free_tier': {'daily_limit': 2, 'rate_limit': '2/day'},
        'pro_tier': {'daily_limit': 100, 'rate_limit': '10/minute'}
    }
}

# Initialize APIs
newsapi = NewsApiClient(api_key=CONFIG['newsapi'])
twitter_api = tweepy.Client(bearer_token=CONFIG['twitter']['bearer_token'])

# Enhanced topic database
TOPIC_DATABASE = {
    # ... (expanded with 20+ industries)
}

# Copywriting templates
FRAMEWORKS = {
    'hook_problem_solution': [
        "ðŸ”¥ {hook} (But here's what nobody is telling you...)",
        "ðŸ’” The REAL problem: {problem}",
        "ðŸ’¡ BREAKTHROUGH: {insight}",
        "ðŸš€ Solution: {solution} (ðŸ‘‰ {cta})"
    ],
    'listicle': [
        "ðŸš€ {count} {topic} Secrets Top Experts Won't Tell You:",
        "1ï¸âƒ£ {point1}",
        "2ï¸âƒ£ {point2}",
        "3ï¸âƒ£ {point3}",
        "ðŸ”‘ The Key: {key_insight} (ðŸ‘‰ {cta})"
    ]
}

CTAS = [
    "Grab your FREE guide â†’ [LINK]",
    "Join our premium community â†’ [LINK]",
    "Book your AI consultation â†’ [LINK]"
]

def get_user_tier(api_key: str) -> str:
    """Check user subscription status"""
    if not api_key:
        return 'free'
    # Implement Stripe check here
    return 'pro'

def fetch_trending_topics() -> List[str]:
    """Aggregate trends from multiple sources with caching"""
    cache_key = f"trends:{datetime.now().strftime('%Y-%m-%d')}"
    
    if redis_client.exists(cache_key):
        return redis_client.smembers(cache_key)
    
    sources = {
        'reddit': fetch_reddit_trends(),
        'twitter': fetch_twitter_trends(),
        'news': fetch_news_trends()
    }
    
    # Combine and weight trends
    all_trends = []
    for source, trends in sources.items():
        all_trends.extend([(t, source) for t in trends])
    
    # Store in Redis with 6h expiration
    redis_client.sadd(cache_key, *[t[0] for t in all_trends])
    redis_client.expire(cache_key, 21600)
    
    return [t[0] for t in all_trends]

def generate_thread_structure(topic: str, insights: List[str]) -> List[str]:
    """Apply copywriting framework to raw insights"""
    framework = random.choice(list(FRAMEWORKS.values()))
    selected_insights = random.sample(insights, len(framework)-1)
    
    thread = []
    for i, template in enumerate(framework):
        thread.append(template.format(
            hook=selected_insights[0],
            problem=selected_insights[1],
            insight=selected_insights[2],
            solution=selected_insights[3],
            cta=random.choice(CTAS),
            # ... other template variables
        ))
    
    # Add viral elements
    thread.insert(1, "ðŸ§µðŸ‘‡ (Thread) â†“")
    thread.append(f"ðŸ’¡ Want more like this? â†’ {random.choice(CTAS)}")
    
    return split_tweets(thread)

def split_tweets(thread: List[str]) -> List[str]:
    """Split long text into tweet-sized chunks"""
    processed = []
    for tweet in thread:
        while len(tweet) > 280:
            split_index = tweet[:250].rfind(' ')
            processed.append(tweet[:split_index] + "â€¦")
            tweet = "â€¦" + tweet[split_index:]
        processed.append(tweet)
    return processed

@app.route('/generate', methods=['POST'])
@limiter.limit(lambda: CONFIG['monetization'][get_user_tier(request.headers.get('API-Key'))]['rate_limit'])
def generate_thread():
    """Main generation endpoint"""
    try:
        # Authentication and authorization
        user_tier = get_user_tier(request.headers.get('X-API-Key'))
        if user_tier == 'free' and redis_client.get(f"usage:{request.remote_addr}") >= CONFIG['monetization']['free_tier']['daily_limit']:
            return jsonify({"error": "Daily limit exceeded. Upgrade to PRO."}), 429
        
        # Process request
        data = request.json
        topic = data.get('topic', random.choice(list(TOPIC_DATABASE.keys())))
        
        # Fetch insights with caching
        insights = get_cached_insights(topic)
        if not insights:
            insights = fetch_fresh_insights(topic)
        
        # Generate thread
        thread = generate_thread_structure(topic, insights)
        
        # Track usage
        if user_tier == 'free':
            redis_client.incr(f"usage:{request.remote_addr}")
        
        return jsonify({
            "thread": thread,
            "cta": random.choice(CTAS),
            "monetization": {
                "upsell": "Unlock 100x more insights with PRO â†’ [LINK]" if user_tier == 'free' else None
            }
        })
    
    except Exception as e:
        logging.error(f"Generation error: {e}")
        return jsonify({"error": str(e)}), 500

# Deployment setup for Railway
if __name__ == '__main__':
    # Database migrations and warmup
    redis_client.ping()
    
    # Start production server
    if os.getenv('ENV') == 'prod':
        from gunicorn.app.base import BaseApplication
        class FlaskApplication(BaseApplication):
            def init(self, parser, opts, args):
                return {'bind': '0.0.0.0:5000'}
            def load(self): return app
        FlaskApplication().run()
    else:
        app.run(debug=True)
